---
title: "Structure of ontologyIndex object"
author: "Sergei Tarasov"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette    #html_vignette #pdf_document:
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
header-includes:
  - \usepackage{color}
---

## Structure of extended ontologyIndex (Matrix+ontology) objects

### Original (most important)
* **ontology$name**, *Vector*, (original)
    + name of AO terms with IDs  
      `HAO:0000000`   
      `[1] "anatomical entity"`  

* **ontology$id**, *Character*, (original)
    + AO ids of terms  
     `HAO:0000000`   
     `[1] "HAO:0000000"` 

* **ontology$synonym**, *List*, (original)
    + unparsed synonyms  
    ` $ SPD:0000003`  
    `[1] "\"abdomen\" EXACT [SPD:Michalik]"`  
* **ontology$parents**, *List*, (original)  
    + term's parents  
    ` $ HAO:0000963`  
    `[1] "HAO:0000221" "HAO:0000909"`
* **ontology$children**, *List*, (original)
    + term's children  
    ` $ HAO:0000994`  
    `[1] "HAO:0001247" "HAO:0001275" "HAO:0001352"`
* **ontology$is_a**, *List*, (original)
    + ` $ HAO:0000994`  
    `[1] "HAO:0001247" "HAO:0001275" "HAO:0001352"`
* **ontology$part_of**, *List*, (original); can be coded as **ontology\$BFO:0000050**
    + ` $ HAO:0000994`  
    `[1] "HAO:0001247" "HAO:0001275" "HAO:0001352"`

********************    
### My entities
* **ontology\$parsed_synonyms**, *Character*  
    + made out of **ontology$synonym** for matching    
      `HAO:0000000`   
      `[1] "anatomical entity"` 
* **ontology$name_characters**, *Character*, **!!!INCLUDE IDs TO NAMES**
    + charcter statements  
    `[1] "Ocellar corona"`  
* **ontology$id_characters**, *Character*
    + chracters IDs automatically generated by ontoFast  
    `[1] "CHAR:1"`
* **ontology$annot_characters**, *List*  
    + character annotations with ontology terms  
    ` $ CHAR:373`  
    `[1] "HAO:0001686" "HAO:0001351"`
    

### To include
* **ontology$id_character_states**, *List*  
    + ` $ CHAR:373`  
    `[1] "state:1" "state:2"`
* **ontology$name_character_states**, *List*  
    + ` $ CHAR:373`  
    `state:1  state:2`  
    `[1]  "absent"  "presnt"`
* **ontology$coding_character_states**, *List*,  **!!!Maybe has to be changed**
    + ` $ CHAR:373`  
    `state:1  state:2 state:3 state:4`  
    `[1]  "0"  "1" "-" "?"`
* **ontology\$depends_upon**, *List*
    + CHAR:1 depends upon CHAR:2 states: 1 and 2; multiple states are allowed if e.g., CHAR:2 (1-green, 2-blue, 3-absent)  
    `$ CHAR:1`  
    `$ CHAR:1 $states` states of CHAR:1 which depend on CHAR:2  
    `[1] "state1" "state2"`  
    `$ CHAR:1 $depends_upon_char`  
    `[1] "CHAR:2"`  
    `$ CHAR:1 $depends_upon_states` statets of CHAR:2 which control CHAR:1  
    `[1] "state1" "state2"`  
* **ontology\$controls_character**. *List*
    + opposite of **ontology\$depends_upon**  
    `$ CHAR:2` it means that CHAR:2 states 1 and 2 control CHAR:1  
    `$ CHAR:2 $states`  
    `[1] "state:1" "state:2"`  
    `$ CHAR:2 $controls`    
    `[1] "CHAR:1"`  
    
* **ontology$character_matrix**, *data.frame*
    + including taxa
* **ontology$modified_characters**, *?List*
    + !!! Must include map for character modification


******

$\left(\begin{array}{cc}
 0 & 0.6 \\
 0.5 & 0 \\
\end{array}\right)$ 
